<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ByteSlice` trait in crate `bstr`."><meta name="keywords" content="rust, rustlang, rust-lang, ByteSlice"><title>bstr::ByteSlice - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../bstr/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Trait ByteSlice</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.as_bstr">as_bstr</a><a href="#method.as_bstr_mut">as_bstr_mut</a><a href="#method.bytes">bytes</a><a href="#method.char_indices">char_indices</a><a href="#method.chars">chars</a><a href="#method.contains_str">contains_str</a><a href="#method.copy_within_str">copy_within_str</a><a href="#method.ends_with_str">ends_with_str</a><a href="#method.fields">fields</a><a href="#method.fields_with">fields_with</a><a href="#method.find">find</a><a href="#method.find_byte">find_byte</a><a href="#method.find_byteset">find_byteset</a><a href="#method.find_char">find_char</a><a href="#method.find_iter">find_iter</a><a href="#method.find_non_ascii_byte">find_non_ascii_byte</a><a href="#method.find_not_byteset">find_not_byteset</a><a href="#method.from_os_str">from_os_str</a><a href="#method.from_path">from_path</a><a href="#method.grapheme_indices">grapheme_indices</a><a href="#method.graphemes">graphemes</a><a href="#method.is_ascii">is_ascii</a><a href="#method.is_utf8">is_utf8</a><a href="#method.last_byte">last_byte</a><a href="#method.lines">lines</a><a href="#method.lines_with_terminator">lines_with_terminator</a><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a><a href="#method.repeatn">repeatn</a><a href="#method.replace">replace</a><a href="#method.replace_into">replace_into</a><a href="#method.replacen">replacen</a><a href="#method.replacen_into">replacen_into</a><a href="#method.reverse_bytes">reverse_bytes</a><a href="#method.reverse_chars">reverse_chars</a><a href="#method.reverse_graphemes">reverse_graphemes</a><a href="#method.rfind">rfind</a><a href="#method.rfind_byte">rfind_byte</a><a href="#method.rfind_byteset">rfind_byteset</a><a href="#method.rfind_char">rfind_char</a><a href="#method.rfind_iter">rfind_iter</a><a href="#method.rfind_not_byteset">rfind_not_byteset</a><a href="#method.rsplit_str">rsplit_str</a><a href="#method.rsplitn_str">rsplitn_str</a><a href="#method.sentence_indices">sentence_indices</a><a href="#method.sentences">sentences</a><a href="#method.split_str">split_str</a><a href="#method.splitn_str">splitn_str</a><a href="#method.starts_with_str">starts_with_str</a><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a><a href="#method.to_lowercase">to_lowercase</a><a href="#method.to_lowercase_into">to_lowercase_into</a><a href="#method.to_os_str">to_os_str</a><a href="#method.to_os_str_lossy">to_os_str_lossy</a><a href="#method.to_path">to_path</a><a href="#method.to_path_lossy">to_path_lossy</a><a href="#method.to_str">to_str</a><a href="#method.to_str_lossy">to_str_lossy</a><a href="#method.to_str_lossy_into">to_str_lossy_into</a><a href="#method.to_str_unchecked">to_str_unchecked</a><a href="#method.to_uppercase">to_uppercase</a><a href="#method.to_uppercase_into">to_uppercase_into</a><a href="#method.trim">trim</a><a href="#method.trim_end">trim_end</a><a href="#method.trim_end_with">trim_end_with</a><a href="#method.trim_start">trim_start</a><a href="#method.trim_start_with">trim_start_with</a><a href="#method.trim_with">trim_with</a><a href="#method.word_indices">word_indices</a><a href="#method.words">words</a><a href="#method.words_with_break_indices">words_with_break_indices</a><a href="#method.words_with_breaks">words_with_breaks</a></div><a class="sidebar-title" href="#foreign-impls">Implementations on Foreign Types</a><div class="sidebar-links"><a href="#impl-ByteSlice-for-%5Bu8%5D">[u8]</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='index.html'>bstr</a></p><script>window.sidebarCurrent = {name: 'ByteSlice', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/bstr/ext_slice.rs.html#95-2926' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='index.html'>bstr</a>::<wbr><a class="trait" href=''>ByteSlice</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait ByteSlice: Sealed {
    fn <a href='#method.as_bstr' class='fnname'>as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="../bstr/struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.as_bstr_mut' class='fnname'>as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../bstr/struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.from_os_str' class='fnname'>from_os_str</a>(os_str: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.from_path' class='fnname'>from_path</a>(path: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_str' class='fnname'>to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<div class='item-spacer'></div>    unsafe fn <a href='#method.to_str_unchecked' class='fnname'>to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_str_lossy' class='fnname'>to_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_str_lossy_into' class='fnname'>to_str_lossy_into</a>(&amp;self, dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_os_str' class='fnname'>to_os_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_os_str_lossy' class='fnname'>to_os_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_path' class='fnname'>to_path</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_path_lossy' class='fnname'>to_path_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.repeatn' class='fnname'>repeatn</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.contains_str' class='fnname'>contains_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.starts_with_str' class='fnname'>starts_with_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.ends_with_str' class='fnname'>ends_with_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_byteset' class='fnname'>find_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_not_byteset' class='fnname'>find_not_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind_byteset' class='fnname'>rfind_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind_not_byteset' class='fnname'>rfind_not_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find' class='fnname'>find</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_iter' class='fnname'>find_iter</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind_iter' class='fnname'>rfind_iter</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_byte' class='fnname'>find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind_byte' class='fnname'>rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_char' class='fnname'>find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rfind_char' class='fnname'>rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.fields' class='fnname'>fields</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Fields.html" title="struct bstr::Fields">Fields</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.fields_with' class='fnname'>fields_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../bstr/struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;F&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.split_str' class='fnname'>split_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rsplit_str' class='fnname'>rsplit_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.splitn_str' class='fnname'>splitn_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.rsplitn_str' class='fnname'>rsplitn_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="../bstr/struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.replace' class='fnname'>replace</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replacement: R<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.replacen' class='fnname'>replacen</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.replace_into' class='fnname'>replace_into</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.replacen_into' class='fnname'>replacen_into</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Bytes.html" title="struct bstr::Bytes">Bytes</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Chars.html" title="struct bstr::Chars">Chars</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.graphemes' class='fnname'>graphemes</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.grapheme_indices' class='fnname'>grapheme_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.words' class='fnname'>words</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Words.html" title="struct bstr::Words">Words</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.word_indices' class='fnname'>word_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.words_with_breaks' class='fnname'>words_with_breaks</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.words_with_break_indices' class='fnname'>words_with_break_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.sentences' class='fnname'>sentences</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Sentences.html" title="struct bstr::Sentences">Sentences</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.sentence_indices' class='fnname'>sentence_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Lines.html" title="struct bstr::Lines">Lines</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.lines_with_terminator' class='fnname'>lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim_start' class='fnname'>trim_start</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim_end' class='fnname'>trim_end</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim_with' class='fnname'>trim_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim_start_with' class='fnname'>trim_start_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.trim_end_with' class='fnname'>trim_end_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_lowercase_into' class='fnname'>to_lowercase_into</a>(&amp;self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_ascii_lowercase' class='fnname'>to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.make_ascii_lowercase' class='fnname'>make_ascii_lowercase</a>(&amp;mut self) { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_uppercase_into' class='fnname'>to_uppercase_into</a>(&amp;self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.to_ascii_uppercase' class='fnname'>to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.make_ascii_uppercase' class='fnname'>make_ascii_uppercase</a>(&amp;mut self) { ... }
<div class='item-spacer'></div>    fn <a href='#method.reverse_bytes' class='fnname'>reverse_bytes</a>(&amp;mut self) { ... }
<div class='item-spacer'></div>    fn <a href='#method.reverse_chars' class='fnname'>reverse_chars</a>(&amp;mut self) { ... }
<div class='item-spacer'></div>    fn <a href='#method.reverse_graphemes' class='fnname'>reverse_graphemes</a>(&amp;mut self) { ... }
<div class='item-spacer'></div>    fn <a href='#method.is_ascii' class='fnname'>is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.is_utf8' class='fnname'>is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.last_byte' class='fnname'>last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.find_non_ascii_byte' class='fnname'>find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.copy_within_str' class='fnname'>copy_within_str</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</span>,
    { ... }
}</pre></div><div class='docblock'><p>A trait that extends a slice of bytes with string oriented methods.</p>
</div>
            <h2 id='provided-methods' class='small-section-header'>Provided methods<a href='#provided-methods' class='anchor'></a></h2><div class='methods'><h3 id='method.as_bstr' class='method'><code id='as_bstr.v'>fn <a href='#method.as_bstr' class='fnname'>as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="../bstr/struct.BStr.html" title="struct bstr::BStr">BStr</a></code></h3><div class='docblock'><p>Return this byte slice as a <code>&amp;BStr</code>.</p>
<p>Use <code>&amp;BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="string">b&quot;foo\xFFbar&quot;</span>.<span class="ident">as_bstr</span>());</pre></div>
</div><h3 id='method.as_bstr_mut' class='method'><code id='as_bstr_mut.v'>fn <a href='#method.as_bstr_mut' class='fnname'>as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../bstr/struct.BStr.html" title="struct bstr::BStr">BStr</a></code></h3><div class='docblock'><p>Return this byte slice as a <code>&amp;mut BStr</code>.</p>
<p>Use <code>&amp;mut BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">*</span><span class="string">b&quot;foo\xFFbar&quot;</span>;
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bytes</span>.<span class="ident">as_bstr_mut</span>());</pre></div>
</div><h3 id='method.from_os_str' class='method'><code id='from_os_str.v'>fn <a href='#method.from_os_str' class='fnname'>from_os_str</a>(os_str: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</code></h3><div class='docblock'><p>Create an immutable byte string from an OS string slice.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this returns <code>None</code> if the given OS string is not valid UTF-8. (For
example, on Windows, file paths are allowed to be a sequence of
arbitrary 16-bit integers. Not all such sequences can be transcoded to
valid UTF-8.)</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">OsStr</span>;

<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">os_str</span> <span class="op">=</span> <span class="ident">OsStr</span>::<span class="ident">new</span>(<span class="string">&quot;foo&quot;</span>);
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>::<span class="ident">from_os_str</span>(<span class="ident">os_str</span>).<span class="ident">expect</span>(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bs</span>, <span class="ident">B</span>(<span class="string">&quot;foo&quot;</span>));</pre></div>
</div><h3 id='method.from_path' class='method'><code id='from_path.v'>fn <a href='#method.from_path' class='fnname'>from_path</a>(path: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</code></h3><div class='docblock'><p>Create an immutable byte string from a file path.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this returns <code>None</code> if the given path is not valid UTF-8. (For example,
on Windows, file paths are allowed to be a sequence of arbitrary 16-bit
integers. Not all such sequences can be transcoded to valid UTF-8.)</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::<span class="ident">Path</span>;

<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="ident">Path</span>::<span class="ident">new</span>(<span class="string">&quot;foo&quot;</span>);
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>::<span class="ident">from_path</span>(<span class="ident">path</span>).<span class="ident">expect</span>(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bs</span>, <span class="ident">B</span>(<span class="string">&quot;foo&quot;</span>));</pre></div>
</div><h3 id='method.to_str' class='method'><code id='to_str.v'>fn <a href='#method.to_str' class='fnname'>to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</code></h3><div class='docblock'><p>Safely convert this byte string into a <code>&amp;str</code> if it's valid UTF-8.</p>
<p>If this byte string is not valid UTF-8, then an error is returned. The
error returned indicates the first invalid byte found and the length
of the error.</p>
<p>In cases where a lossy conversion to <code>&amp;str</code> is acceptable, then use one
of the <a href="trait.ByteSlice.html#method.to_str_lossy"><code>to_str_lossy</code></a> or
<a href="trait.ByteSlice.html#method.to_str_lossy_into"><code>to_str_lossy_into</code></a>
methods.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>, <span class="ident">ByteVec</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;☃βツ&quot;</span>).<span class="ident">to_str</span>()<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;☃βツ&quot;</span>, <span class="ident">s</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bstring</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;☃βツ&quot;</span>);
<span class="ident">bstring</span>.<span class="ident">push</span>(<span class="string">b&#39;\xFF&#39;</span>);
<span class="kw">let</span> <span class="ident">err</span> <span class="op">=</span> <span class="ident">bstring</span>.<span class="ident">to_str</span>().<span class="ident">unwrap_err</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">8</span>, <span class="ident">err</span>.<span class="ident">valid_up_to</span>());</pre></div>
</div><h3 id='method.to_str_unchecked' class='method'><code id='to_str_unchecked.v'>unsafe fn <a href='#method.to_str_unchecked' class='fnname'>to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></h3><div class='docblock'><p>Unsafely convert this byte string into a <code>&amp;str</code>, without checking for
valid UTF-8.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Callers <em>must</em> ensure that this byte string is valid UTF-8 before
calling this method. Converting a byte string into a <code>&amp;str</code> that is
not valid UTF-8 is considered undefined behavior.</p>
<p>This routine is useful in performance sensitive contexts where the
UTF-8 validity of the byte string is already known and it is
undesirable to pay the cost of an additional UTF-8 validation check
that <a href="trait.ByteSlice.html#method.to_str"><code>to_str</code></a> performs.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="comment">// SAFETY: This is safe because string literals are guaranteed to be</span>
<span class="comment">// valid UTF-8 by the Rust compiler.</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">B</span>(<span class="string">&quot;☃βツ&quot;</span>).<span class="ident">to_str_unchecked</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;☃βツ&quot;</span>, <span class="ident">s</span>);</pre></div>
</div><h3 id='method.to_str_lossy' class='method'><code id='to_str_lossy.v'>fn <a href='#method.to_str_lossy' class='fnname'>to_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</code></h3><div class='docblock'><p>Convert this byte string to a valid UTF-8 string by replacing invalid
UTF-8 bytes with the Unicode replacement codepoint (<code>U+FFFD</code>).</p>
<p>If the byte string is already valid UTF-8, then no copying or
allocation is performed and a borrrowed string slice is returned. If
the byte string is not valid UTF-8, then an owned string buffer is
returned with invalid bytes replaced by the replacement codepoint.</p>
<p>This method uses the &quot;substitution of maximal subparts&quot; (Unicode
Standard, Chapter 3, Section 9) strategy for inserting the replacement
codepoint. Specifically, a replacement codepoint is inserted whenever a
byte is found that cannot possibly lead to a valid code unit sequence.
If there were previous bytes that represented a prefix of a well-formed
code unit sequence, then all of those bytes are substituted with a
single replacement codepoint. The &quot;substitution of maximal subparts&quot;
strategy is the same strategy used by
<a href="https://www.w3.org/TR/encoding/">W3C's Encoding standard</a>.
For a more precise description of the maximal subpart strategy, see
the Unicode Standard, Chapter 3, Section 9. See also
<a href="http://www.unicode.org/review/pr-121.html">Public Review Issue #121</a>.</p>
<p>N.B. Rust's standard library also appears to use the same strategy,
but it does not appear to be an API guarantee.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">borrow</span>::<span class="ident">Cow</span>;

<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bstring</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;☃βツ&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Cow</span>::<span class="ident">Borrowed</span>(<span class="string">&quot;☃βツ&quot;</span>), <span class="ident">bstring</span>.<span class="ident">to_str_lossy</span>());

<span class="comment">// Add a byte that makes the sequence invalid.</span>
<span class="ident">bstring</span>.<span class="ident">push</span>(<span class="string">b&#39;\xFF&#39;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Cow</span>::<span class="ident">Borrowed</span>(<span class="string">&quot;☃βツ\u{FFFD}&quot;</span>), <span class="ident">bstring</span>.<span class="ident">to_str_lossy</span>());</pre></div>
<p>This demonstrates the &quot;maximal subpart&quot; substitution logic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="comment">// \x61 is the ASCII codepoint for &#39;a&#39;.</span>
<span class="comment">// \xF1\x80\x80 is a valid 3-byte code unit prefix.</span>
<span class="comment">// \xE1\x80 is a valid 2-byte code unit prefix.</span>
<span class="comment">// \xC2 is a valid 1-byte code unit prefix.</span>
<span class="comment">// \x62 is the ASCII codepoint for &#39;b&#39;.</span>
<span class="comment">//</span>
<span class="comment">// In sum, each of the prefixes is replaced by a single replacement</span>
<span class="comment">// codepoint since none of the prefixes are properly completed. This</span>
<span class="comment">// is in contrast to other strategies that might insert a replacement</span>
<span class="comment">// codepoint for every single byte.</span>
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;\x61\xF1\x80\x80\xE1\x80\xC2\x62&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;a\u{FFFD}\u{FFFD}\u{FFFD}b&quot;</span>, <span class="ident">bs</span>.<span class="ident">to_str_lossy</span>());</pre></div>
</div><h3 id='method.to_str_lossy_into' class='method'><code id='to_str_lossy_into.v'>fn <a href='#method.to_str_lossy_into' class='fnname'>to_str_lossy_into</a>(&amp;self, dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)</code></h3><div class='docblock'><p>Copy the contents of this byte string into the given owned string
buffer, while replacing invalid UTF-8 code unit sequences with the
Unicode replacement codepoint (<code>U+FFFD</code>).</p>
<p>This method uses the same &quot;substitution of maximal subparts&quot; strategy
for inserting the replacement codepoint as the
<a href="trait.ByteSlice.html#method.to_str_lossy"><code>to_str_lossy</code></a> method.</p>
<p>This routine is useful for amortizing allocation. However, unlike
<code>to_str_lossy</code>, this routine will <em>always</em> copy the contents of this
byte string into the destination buffer, even if this byte string is
valid UTF-8.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">borrow</span>::<span class="ident">Cow</span>;

<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bstring</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;☃βツ&quot;</span>);
<span class="comment">// Add a byte that makes the sequence invalid.</span>
<span class="ident">bstring</span>.<span class="ident">push</span>(<span class="string">b&#39;\xFF&#39;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">bstring</span>.<span class="ident">to_str_lossy_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;☃βツ\u{FFFD}&quot;</span>, <span class="ident">dest</span>);</pre></div>
</div><h3 id='method.to_os_str' class='method'><code id='to_os_str.v'>fn <a href='#method.to_os_str' class='fnname'>to_os_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</code></h3><div class='docblock'><p>Create an OS string slice from this byte string.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this returns a UTF-8 decoding error if this byte string is not valid
UTF-8. (For example, on Windows, file paths are allowed to be a
sequence of arbitrary 16-bit integers. There is no obvious mapping from
an arbitrary sequence of 8-bit integers to an arbitrary sequence of
16-bit integers.)</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">os_str</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">to_os_str</span>().<span class="ident">expect</span>(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">os_str</span>, <span class="string">&quot;foo&quot;</span>);</pre></div>
</div><h3 id='method.to_os_str_lossy' class='method'><code id='to_os_str_lossy.v'>fn <a href='#method.to_os_str_lossy' class='fnname'>to_os_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>&gt;</code></h3><div class='docblock'><p>Lossily create an OS string slice from this byte string.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this will perform a UTF-8 check and lossily convert this byte string
into valid UTF-8 using the Unicode replacement codepoint.</p>
<p>Note that this can prevent the correct roundtripping of file paths on
non-Unix systems such as Windows, where file paths are an arbitrary
sequence of 16-bit integers.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">os_str</span> <span class="op">=</span> <span class="string">b&quot;foo\xFFbar&quot;</span>.<span class="ident">to_os_str_lossy</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">os_str</span>.<span class="ident">to_string_lossy</span>(), <span class="string">&quot;foo\u{FFFD}bar&quot;</span>);</pre></div>
</div><h3 id='method.to_path' class='method'><code id='to_path.v'>fn <a href='#method.to_path' class='fnname'>to_path</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>, <a class="struct" href="../bstr/struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</code></h3><div class='docblock'><p>Create a path slice from this byte string.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this returns a UTF-8 decoding error if this byte string is not valid
UTF-8. (For example, on Windows, file paths are allowed to be a
sequence of arbitrary 16-bit integers. There is no obvious mapping from
an arbitrary sequence of 8-bit integers to an arbitrary sequence of
16-bit integers.)</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">to_path</span>().<span class="ident">expect</span>(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">path</span>.<span class="ident">as_os_str</span>(), <span class="string">&quot;foo&quot;</span>);</pre></div>
</div><h3 id='method.to_path_lossy' class='method'><code id='to_path_lossy.v'>fn <a href='#method.to_path_lossy' class='fnname'>to_path_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;</code></h3><div class='docblock'><p>Lossily create a path slice from this byte string.</p>
<p>On Unix, this always succeeds and is zero cost. On non-Unix systems,
this will perform a UTF-8 check and lossily convert this byte string
into valid UTF-8 using the Unicode replacement codepoint.</p>
<p>Note that this can prevent the correct roundtripping of file paths on
non-Unix systems such as Windows, where file paths are an arbitrary
sequence of 16-bit integers.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;foo\xFFbar&quot;</span>;
<span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">to_path_lossy</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">path</span>.<span class="ident">to_string_lossy</span>(), <span class="string">&quot;foo\u{FFFD}bar&quot;</span>);</pre></div>
</div><h3 id='method.repeatn' class='method'><code id='repeatn.v'>fn <a href='#method.repeatn' class='fnname'>repeatn</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Create a new byte string by repeating this byte string <code>n</code> times.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This function panics if the capacity of the new byte string would
overflow.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo&quot;</span>.<span class="ident">repeatn</span>(<span class="number">4</span>), <span class="ident">B</span>(<span class="string">&quot;foofoofoofoo&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo&quot;</span>.<span class="ident">repeatn</span>(<span class="number">0</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>));</pre></div>
</div><h3 id='method.contains_str' class='method'><code id='contains_str.v'>fn <a href='#method.contains_str' class='fnname'>contains_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Returns true if and only if this byte string contains the given needle.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="string">b&quot;foo bar&quot;</span>.<span class="ident">contains_str</span>(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="string">b&quot;foo bar&quot;</span>.<span class="ident">contains_str</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">b&quot;foo&quot;</span>.<span class="ident">contains_str</span>(<span class="string">&quot;foobar&quot;</span>));</pre></div>
</div><h3 id='method.starts_with_str' class='method'><code id='starts_with_str.v'>fn <a href='#method.starts_with_str' class='fnname'>starts_with_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Returns true if and only if this byte string has the given prefix.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="string">b&quot;foo bar&quot;</span>.<span class="ident">starts_with_str</span>(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">b&quot;foo bar&quot;</span>.<span class="ident">starts_with_str</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">b&quot;foo&quot;</span>.<span class="ident">starts_with_str</span>(<span class="string">&quot;foobar&quot;</span>));</pre></div>
</div><h3 id='method.ends_with_str' class='method'><code id='ends_with_str.v'>fn <a href='#method.ends_with_str' class='fnname'>ends_with_str</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Returns true if and only if this byte string has the given suffix.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="string">b&quot;foo bar&quot;</span>.<span class="ident">ends_with_str</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">b&quot;foo bar&quot;</span>.<span class="ident">ends_with_str</span>(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">b&quot;bar&quot;</span>.<span class="ident">ends_with_str</span>(<span class="string">&quot;foobar&quot;</span>));</pre></div>
</div><h3 id='method.find_byteset' class='method'><code id='find_byteset.v'>fn <a href='#method.find_byteset' class='fnname'>find_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h1 id="complexity" class="section-header"><a href="#complexity">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_byteset</span>(<span class="string">b&quot;zr&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">find_byteset</span>(<span class="string">b&quot;bzr&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">find_byteset</span>(<span class="string">b&quot;\t\n&quot;</span>));</pre></div>
</div><h3 id='method.find_not_byteset' class='method'><code id='find_not_byteset.v'>fn <a href='#method.find_not_byteset' class='fnname'>find_not_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first occurrence of a byte that is not a member
of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h1 id="complexity-1" class="section-header"><a href="#complexity-1">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_not_byteset</span>(<span class="string">b&quot;fo &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;\t\tbaz bar&quot;</span>.<span class="ident">find_not_byteset</span>(<span class="string">b&quot; \t\r\n&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo\nbaz\tbar&quot;</span>.<span class="ident">find_not_byteset</span>(<span class="string">b&quot;\t\n&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));</pre></div>
</div><h3 id='method.rfind_byteset' class='method'><code id='rfind_byteset.v'>fn <a href='#method.rfind_byteset' class='fnname'>rfind_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the last occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and duplicate
bytes present in its body are ignored.</p>
<h1 id="complexity-2" class="section-header"><a href="#complexity-2">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">rfind_byteset</span>(<span class="string">b&quot;agb&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">rfind_byteset</span>(<span class="string">b&quot;rabz &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">rfind_byteset</span>(<span class="string">b&quot;\n123&quot;</span>), <span class="prelude-val">None</span>);</pre></div>
</div><h3 id='method.rfind_not_byteset' class='method'><code id='rfind_not_byteset.v'>fn <a href='#method.rfind_not_byteset' class='fnname'>rfind_not_byteset</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the last occurrence of a byte that is not a member
of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h1 id="complexity-3" class="section-header"><a href="#complexity-3">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo bar baz,\t&quot;</span>.<span class="ident">rfind_not_byteset</span>(<span class="string">b&quot;,\t&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">rfind_not_byteset</span>(<span class="string">b&quot;rabz &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo baz bar&quot;</span>.<span class="ident">rfind_not_byteset</span>(<span class="string">b&quot;barfoz &quot;</span>));</pre></div>
</div><h3 id='method.find' class='method'><code id='find.v'>fn <a href='#method.find' class='fnname'>find</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you're are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.Finder.html"><code>Finder</code></a> once, and reuse it for each search.</p>
<h1 id="complexity-4" class="section-header"><a href="#complexity-4">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo bar baz&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), <span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;quux&quot;</span>));</pre></div>
</div><h3 id='method.rfind' class='method'><code id='rfind.v'>fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the last occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you're are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.FinderReverse.html"><code>FinderReverse</code></a> once, and reuse it for
each search.</p>
<h1 id="complexity-5" class="section-header"><a href="#complexity-5">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo bar baz&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), <span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), <span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;ba&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;quux&quot;</span>));</pre></div>
</div><h3 id='method.find_iter' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>;</span></code></div></div><code id='find_iter.v'>fn <a href='#method.find_iter' class='fnname'>find_iter</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B) -&gt; <a class="struct" href="../bstr/struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator of the non-overlapping occurrences of the given
needle. The iterator yields byte offset positions indicating the start
of each match.</p>
<h1 id="complexity-6" class="section-header"><a href="#complexity-6">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo bar foo foo quux foo&quot;</span>;
<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">find_iter</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>]);</pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">find_iter</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">find_iter</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>]);</pre></div>
</div><h3 id='method.rfind_iter' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>;</span></code></div></div><code id='rfind_iter.v'>fn <a href='#method.rfind_iter' class='fnname'>rfind_iter</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>) -&gt; <a class="struct" href="../bstr/struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator of the non-overlapping occurrences of the given
needle in reverse. The iterator yields byte offset positions indicating
the start of each match.</p>
<h1 id="complexity-7" class="section-header"><a href="#complexity-7">Complexity</a></h1>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo bar foo foo quux foo&quot;</span>;
<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">rfind_iter</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">21</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">0</span>]);</pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">rfind_iter</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">rfind_iter</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">matches</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>]);</pre></div>
</div><h3 id='method.find_byte' class='method'><code id='find_byte.v'>fn <a href='#method.find_byte' class='fnname'>find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_byte</span>(<span class="string">b&#39;z&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_byte</span>(<span class="string">b&#39;y&#39;</span>));</pre></div>
</div><h3 id='method.rfind_byte' class='method'><code id='rfind_byte.v'>fn <a href='#method.rfind_byte' class='fnname'>rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the last occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">rfind_byte</span>(<span class="string">b&#39;z&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">rfind_byte</span>(<span class="string">b&#39;y&#39;</span>));</pre></div>
</div><h3 id='method.find_char' class='method'><code id='find_char.v'>fn <a href='#method.find_char' class='fnname'>find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_char</span>(<span class="string">&#39;z&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), <span class="ident">B</span>(<span class="string">&quot;αβγγδ&quot;</span>).<span class="ident">find_char</span>(<span class="string">&#39;γ&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">find_char</span>(<span class="string">&#39;y&#39;</span>));</pre></div>
</div><h3 id='method.rfind_char' class='method'><code id='rfind_char.v'>fn <a href='#method.rfind_char' class='fnname'>rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the last occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">rfind_char</span>(<span class="string">&#39;z&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>), <span class="ident">B</span>(<span class="string">&quot;αβγγδ&quot;</span>).<span class="ident">rfind_char</span>(<span class="string">&#39;γ&#39;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.<span class="ident">rfind_char</span>(<span class="string">&#39;y&#39;</span>));</pre></div>
</div><h3 id='method.fields' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Fields.html" title="struct bstr::Fields">Fields</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Fields.html" title="struct bstr::Fields">Fields</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Fields.html" title="struct bstr::Fields">Fields</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='fields.v'>fn <a href='#method.fields' class='fnname'>fields</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Fields.html" title="struct bstr::Fields">Fields</a></code></h3><div class='docblock'><p>Returns an iterator over the fields in a byte string, separated by
contiguous whitespace.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;  foo\tbar\t\u{2003}\nquux   \n&quot;</span>);
<span class="kw">let</span> <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">fields</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">fields</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;quux&quot;</span>)]);</pre></div>
<p>A byte string consisting of just whitespace yields no elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0</span>, <span class="ident">B</span>(<span class="string">&quot;  \n\t\u{2003}\n  \t&quot;</span>).<span class="ident">fields</span>().<span class="ident">count</span>());</pre></div>
</div><h3 id='method.fields_with' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'a, F&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'a, F&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'a, F&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='fields_with.v'>fn <a href='#method.fields_with' class='fnname'>fields_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../bstr/struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;F&gt;</code></h3><div class='docblock'><p>Returns an iterator over the fields in a byte string, separated by
contiguous codepoints satisfying the given predicate.</p>
<p>If this byte string is not valid UTF-8, then the given closure will
be called with a Unicode replacement codepoint when invalid UTF-8
bytes are seen.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;123foo999999bar1quux123456&quot;</span>;
<span class="kw">let</span> <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">fields_with</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_numeric</span>()).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">fields</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;quux&quot;</span>)]);</pre></div>
<p>A byte string consisting of all codepoints satisfying the predicate
yields no elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0</span>, <span class="string">b&quot;1911354563&quot;</span>.<span class="ident">fields_with</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_numeric</span>()).<span class="ident">count</span>());</pre></div>
</div><h3 id='method.split_str' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='split_str.v'>fn <a href='#method.split_str' class='fnname'>split_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>) -&gt; <a class="struct" href="../bstr/struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator over substrings of this byte string, separated
by the given byte string. Each element yielded is guaranteed not to
include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;Mary had a little lamb&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;lamb&quot;</span>),
]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>)]);</pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;||||a||b|c&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;|&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;c&quot;</span>),
]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;(///)&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;(&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;)&quot;</span>)]);</pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;010&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;1&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>)]);</pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;rust&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;r&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;u&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;s&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;t&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded</span>
<span class="comment">// may not be valid UTF-8!</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;☃&quot;</span>).<span class="ident">split_str</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\xE2&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\x98&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\x83&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>),
]);</pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;    a  b c&quot;</span>.<span class="ident">split_str</span>(<span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;c&quot;</span>),
]);</pre></div>
<p>It does <em>not</em> give you <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>. For that behavior, use
<a href="#method.fields"><code>fields</code></a> instead.</p>
</div><h3 id='method.rsplit_str' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='rsplit_str.v'>fn <a href='#method.rsplit_str' class='fnname'>rsplit_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>) -&gt; <a class="struct" href="../bstr/struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator over substrings of this byte string, separated by
the given byte string, in reverse. Each element yielded is guaranteed
not to include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span>
    <span class="string">b&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;Mary&quot;</span>),
]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>)]);</pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;||||a||b|c&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;|&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;c&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>),
]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;(///)&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;)&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;(&quot;</span>)]);</pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;010&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;1&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>)]);</pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;rust&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;t&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;s&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;u&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;r&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded</span>
<span class="comment">// may not be valid UTF-8!</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;☃&quot;</span>).<span class="ident">rsplit_str</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\x83&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\x98&quot;</span>), <span class="ident">B</span>(<span class="string">b&quot;\xE2&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>)]);</pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;    a  b c&quot;</span>.<span class="ident">rsplit_str</span>(<span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;c&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>),
]);</pre></div>
<p>It does <em>not</em> give you <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>.</p>
</div><h3 id='method.splitn_str' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='splitn_str.v'>fn <a href='#method.splitn_str' class='fnname'>splitn_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>) -&gt; <a class="struct" href="../bstr/struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string. If <code>limit</code> substrings are yielded,
then the last substring will contain the remainder of this byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;Mary had a little lamb&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">3</span>, <span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;a little lamb&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tigerXleopard&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lion::tiger::leopard&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;lion&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger::leopard&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;abcXdef&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">1</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;abcXdef&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;abcXdef&quot;</span>.<span class="ident">splitn_str</span>(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h3 id='method.rsplitn_str' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='rsplitn_str.v'>fn <a href='#method.rsplitn_str' class='fnname'>rsplitn_str</a>&lt;'a, B:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;splitter: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>B<br>) -&gt; <a class="struct" href="../bstr/struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt;</code></h3><div class='docblock'><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string, in reverse. If <code>limit</code> substrings
are yielded, then the last substring will contain the remainder of this
byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span>
    <span class="string">b&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">3</span>, <span class="string">&quot; &quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;Mary had a&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;tiger&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;lionX&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;leopard&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;lion::tiger&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;abcXdef&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">1</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">B</span>(<span class="string">&quot;abcXdef&quot;</span>)]);

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">b&quot;abcXdef&quot;</span>.<span class="ident">rsplitn_str</span>(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h3 id='method.replace' class='method'><code id='replace.v'>fn <a href='#method.replace' class='fnname'>replace</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;replacement: R<br>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Replace all matches of the given needle with the given replacement, and
the result as a new <code>Vec&lt;u8&gt;</code>.</p>
<p>This routine is useful as a convenience. If you need to reuse an
allocation, use <a href="#method.replace_into"><code>replace_into</code></a> instead.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;this is old&quot;</span>.<span class="ident">replace</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;this is new&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;this is old&quot;</span>.<span class="ident">replace</span>(<span class="string">&quot;nada nada&quot;</span>, <span class="string">&quot;limonada&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;this is old&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">replace</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;ZfZoZoZ&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.replacen' class='method'><code id='replacen.v'>fn <a href='#method.replacen' class='fnname'>replacen</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Replace up to <code>limit</code> matches of the given needle with the given
replacement, and the result as a new <code>Vec&lt;u8&gt;</code>.</p>
<p>This routine is useful as a convenience. If you need to reuse an
allocation, use <a href="#method.replacen_into"><code>replacen_into</code></a> instead.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foofoo&quot;</span>.<span class="ident">replacen</span>(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;fzzfoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foofoo&quot;</span>.<span class="ident">replacen</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;foofoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>.<span class="ident">replacen</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;ZfZoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.replace_into' class='method'><code id='replace_into.v'>fn <a href='#method.replace_into' class='fnname'>replace_into</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;<br>)</code></h3><div class='docblock'><p>Replace all matches of the given needle with the given replacement,
and write the result into the provided <code>Vec&lt;u8&gt;</code>.</p>
<p>This does <strong>not</strong> clear <code>dest</code> before writing to it.</p>
<p>This routine is useful for reusing allocation. For a more convenient
API, use <a href="#method.replace"><code>replace</code></a> instead.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;this is old&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replace_into</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;this is new&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;this is old&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replace_into</span>(<span class="string">&quot;nada nada&quot;</span>, <span class="string">&quot;limonada&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;this is old&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replace_into</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;ZfZoZoZ&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.replacen_into' class='method'><code id='replacen_into.v'>fn <a href='#method.replacen_into' class='fnname'>replacen_into</a>&lt;N:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;needle: N, <br>&nbsp;&nbsp;&nbsp;&nbsp;replacement: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;<br>)</code></h3><div class='docblock'><p>Replace up to <code>limit</code> matches of the given needle with the given
replacement, and write the result into the provided <code>Vec&lt;u8&gt;</code>.</p>
<p>This does <strong>not</strong> clear <code>dest</code> before writing to it.</p>
<p>This routine is useful for reusing allocation. For a more convenient
API, use <a href="#method.replacen"><code>replacen</code></a> instead.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foofoo&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replacen_into</span>(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;fzzfoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foofoo&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replacen_into</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;foofoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;foo&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">replacen_into</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dest</span>, <span class="string">&quot;ZfZoo&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.bytes' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>;</span></code></div></div><code id='bytes.v'>fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Bytes.html" title="struct bstr::Bytes">Bytes</a></code></h3><div class='docblock'><p>Returns an iterator over the bytes in this byte string.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;foobar&quot;</span>;
<span class="kw">let</span> <span class="ident">bytes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">bytes</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bytes</span>, <span class="ident">bs</span>);</pre></div>
</div><h3 id='method.chars' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><code id='chars.v'>fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Chars.html" title="struct bstr::Chars">Chars</a></code></h3><div class='docblock'><p>Returns an iterator over the Unicode scalar values in this byte string.
If invalid UTF-8 is encountered, then the Unicode replacement codepoint
is yielded instead.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let</span> <span class="ident">chars</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">char</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">chars</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&#39;☃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;𝞃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;a&#39;</span>], <span class="ident">chars</span>);</pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let</span> <span class="ident">chars</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">char</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&#39;a&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;𝞃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;☃&#39;</span>], <span class="ident">chars</span>);</pre></div>
</div><h3 id='method.char_indices' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='char_indices.v'>fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a></code></h3><div class='docblock'><p>Returns an iterator over the Unicode scalar values in this byte string
along with their starting and ending byte index positions. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<p>Note that this is slightly different from the <code>CharIndices</code> iterator
provided by the standard library. Aside from working on possibly
invalid UTF-8, this iterator provides both the corresponding starting
and ending byte indices of each codepoint yielded. The ending position
is necessary to slice the original byte string when invalid UTF-8 bytes
are converted into a Unicode replacement codepoint, since a single
replacement codepoint can substitute anywhere from 1 to 3 invalid bytes
(inclusive).</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let</span> <span class="ident">chars</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="ident">char</span>)<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">char_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chars</span>, <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#39;☃&#39;</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">&#39;𝞃&#39;</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">&#39;a&#39;</span>),
]);</pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let</span> <span class="ident">chars</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="ident">char</span>)<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>
    .<span class="ident">char_indices</span>()
    .<span class="ident">rev</span>()
    .<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chars</span>, <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">&#39;a&#39;</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">&#39;𝞃&#39;</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#39;☃&#39;</span>),
]);</pre></div>
</div><h3 id='method.graphemes' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='graphemes.v'>fn <a href='#method.graphemes' class='fnname'>graphemes</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a></code></h3><div class='docblock'><p>Returns an iterator over the grapheme clusters in this byte string.
If invalid UTF-8 is encountered, then the Unicode replacement codepoint
is yielded instead.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<p>This example shows how multiple codepoints can combine to form a
single grapheme cluster:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">&quot;a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}&quot;</span>.<span class="ident">as_bytes</span>();
<span class="kw">let</span> <span class="ident">graphemes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">graphemes</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;à̖&quot;</span>, <span class="string">&quot;🇺🇸&quot;</span>], <span class="ident">graphemes</span>);</pre></div>
<p>This shows that graphemes can be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">&quot;a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}&quot;</span>.<span class="ident">as_bytes</span>();
<span class="kw">let</span> <span class="ident">graphemes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">graphemes</span>().<span class="ident">rev</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;🇺🇸&quot;</span>, <span class="string">&quot;à̖&quot;</span>], <span class="ident">graphemes</span>);</pre></div>
</div><h3 id='method.grapheme_indices' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='grapheme_indices.v'>fn <a href='#method.grapheme_indices' class='fnname'>grapheme_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a></code></h3><div class='docblock'><p>Returns an iterator over the grapheme clusters in this byte string
along with their starting and ending byte index positions. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<p>This example shows how to get the byte offsets of each individual
grapheme cluster:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">&quot;a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}&quot;</span>.<span class="ident">as_bytes</span>();
<span class="kw">let</span> <span class="ident">graphemes</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">&gt;</span> <span class="op">=</span>
    <span class="ident">bs</span>.<span class="ident">grapheme_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[(<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;à̖&quot;</span>), (<span class="number">5</span>, <span class="number">13</span>, <span class="string">&quot;🇺🇸&quot;</span>)], <span class="ident">graphemes</span>);</pre></div>
<p>This example shows what happens when invalid UTF-8 is enountered. Note
that the offsets are valid indices into the original string, and do
not necessarily correspond to the length of the <code>&amp;str</code> returned!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">ByteSlice</span>, <span class="ident">ByteVec</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">bytes</span>.<span class="ident">push_str</span>(<span class="string">&quot;a\u{0300}\u{0316}&quot;</span>);
<span class="ident">bytes</span>.<span class="ident">push</span>(<span class="string">b&#39;\xFF&#39;</span>);
<span class="ident">bytes</span>.<span class="ident">push_str</span>(<span class="string">&quot;\u{1F1FA}\u{1F1F8}&quot;</span>);

<span class="kw">let</span> <span class="ident">graphemes</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">&gt;</span> <span class="op">=</span>
    <span class="ident">bytes</span>.<span class="ident">grapheme_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">graphemes</span>,
    <span class="macro">vec</span><span class="macro">!</span>[(<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;à̖&quot;</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;\u{FFFD}&quot;</span>), (<span class="number">6</span>, <span class="number">14</span>, <span class="string">&quot;🇺🇸&quot;</span>)]
);</pre></div>
</div><h3 id='method.words' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Words.html" title="struct bstr::Words">Words</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Words.html" title="struct bstr::Words">Words</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Words.html" title="struct bstr::Words">Words</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='words.v'>fn <a href='#method.words' class='fnname'>words</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Words.html" title="struct bstr::Words">Words</a></code></h3><div class='docblock'><p>Returns an iterator over the words in this byte string. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<p>This is similar to
<a href="trait.ByteSlice.html#method.words_with_breaks"><code>words_with_breaks</code></a>,
except it only returns elements that contain a &quot;word&quot; character. A word
character is defined by UTS #18 (Annex C) to be the combination of the
<code>Alphabetic</code> and <code>Join_Control</code> properties, along with the
<code>Decimal_Number</code>, <code>Mark</code> and <code>Connector_Punctuation</code> general
categories.</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">br#&quot;The quick (&quot;brown&quot;) fox can&#39;t jump 32.3 feet, right?&quot;#</span>;
<span class="kw">let</span> <span class="ident">words</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">words</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="string">&quot;The&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;can&#39;t&quot;</span>,
    <span class="string">&quot;jump&quot;</span>, <span class="string">&quot;32.3&quot;</span>, <span class="string">&quot;feet&quot;</span>, <span class="string">&quot;right&quot;</span>,
]);</pre></div>
</div><h3 id='method.word_indices' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='word_indices.v'>fn <a href='#method.word_indices' class='fnname'>word_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a></code></h3><div class='docblock'><p>Returns an iterator over the words in this byte string along with
their starting and ending byte index positions.</p>
<p>This is similar to
<a href="trait.ByteSlice.html#method.words_with_break_indices"><code>words_with_break_indices</code></a>,
except it only returns elements that contain a &quot;word&quot; character. A word
character is defined by UTS #18 (Annex C) to be the combination of the
<code>Alphabetic</code> and <code>Join_Control</code> properties, along with the
<code>Decimal_Number</code>, <code>Mark</code> and <code>Connector_Punctuation</code> general
categories.</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<p>This example shows how to get the byte offsets of each individual
word:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;can&#39;t jump 32.3 feet&quot;</span>;
<span class="kw">let</span> <span class="ident">words</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">word_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>, <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;can&#39;t&quot;</span>),
    (<span class="number">6</span>, <span class="number">10</span>, <span class="string">&quot;jump&quot;</span>),
    (<span class="number">11</span>, <span class="number">15</span>, <span class="string">&quot;32.3&quot;</span>),
    (<span class="number">16</span>, <span class="number">20</span>, <span class="string">&quot;feet&quot;</span>),
]);</pre></div>
</div><h3 id='method.words_with_breaks' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='words_with_breaks.v'>fn <a href='#method.words_with_breaks' class='fnname'>words_with_breaks</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a></code></h3><div class='docblock'><p>Returns an iterator over the words in this byte string, along with
all breaks between the words. Concatenating all elements yielded by
the iterator results in the original string (modulo Unicode replacement
codepoint substitutions if invalid UTF-8 is encountered).</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">br#&quot;The quick (&quot;brown&quot;) fox can&#39;t jump 32.3 feet, right?&quot;#</span>;
<span class="kw">let</span> <span class="ident">words</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">words_with_breaks</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="string">&quot;The&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>,
    <span class="string">&quot; &quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;can&#39;t&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;jump&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;32.3&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;feet&quot;</span>,
    <span class="string">&quot;,&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;?&quot;</span>,
]);</pre></div>
</div><h3 id='method.words_with_break_indices' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='words_with_break_indices.v'>fn <a href='#method.words_with_break_indices' class='fnname'>words_with_break_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a></code></h3><div class='docblock'><p>Returns an iterator over the words and their byte offsets in this
byte string, along with all breaks between the words. Concatenating
all elements yielded by the iterator results in the original string
(modulo Unicode replacement codepoint substitutions if invalid UTF-8 is
encountered).</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<p>This example shows how to get the byte offsets of each individual
word:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;can&#39;t jump 32.3 feet&quot;</span>;
<span class="kw">let</span> <span class="ident">words</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">&gt;</span> <span class="op">=</span>
    <span class="ident">bs</span>.<span class="ident">words_with_break_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>, <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;can&#39;t&quot;</span>),
    (<span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot; &quot;</span>),
    (<span class="number">6</span>, <span class="number">10</span>, <span class="string">&quot;jump&quot;</span>),
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">&quot; &quot;</span>),
    (<span class="number">11</span>, <span class="number">15</span>, <span class="string">&quot;32.3&quot;</span>),
    (<span class="number">15</span>, <span class="number">16</span>, <span class="string">&quot; &quot;</span>),
    (<span class="number">16</span>, <span class="number">20</span>, <span class="string">&quot;feet&quot;</span>),
]);</pre></div>
</div><h3 id='method.sentences' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Sentences.html" title="struct bstr::Sentences">Sentences</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Sentences.html" title="struct bstr::Sentences">Sentences</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Sentences.html" title="struct bstr::Sentences">Sentences</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='sentences.v'>fn <a href='#method.sentences' class='fnname'>sentences</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Sentences.html" title="struct bstr::Sentences">Sentences</a></code></h3><div class='docblock'><p>Returns an iterator over the sentences in this byte string.</p>
<p>Typically, a sentence will include its trailing punctuation and
whitespace. Concatenating all elements yielded by the iterator
results in the original string (modulo Unicode replacement codepoint
substitutions if invalid UTF-8 is encountered).</p>
<p>Since sentences are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;I want this. Not that. Right now.&quot;</span>;
<span class="kw">let</span> <span class="ident">sentences</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bs</span>.<span class="ident">sentences</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sentences</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="string">&quot;I want this. &quot;</span>,
    <span class="string">&quot;Not that. &quot;</span>,
    <span class="string">&quot;Right now.&quot;</span>,
]);</pre></div>
</div><h3 id='method.sentence_indices' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='sentence_indices.v'>fn <a href='#method.sentence_indices' class='fnname'>sentence_indices</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a></code></h3><div class='docblock'><p>Returns an iterator over the sentences in this byte string along with
their starting and ending byte index positions.</p>
<p>Typically, a sentence will include its trailing punctuation and
whitespace. Concatenating all elements yielded by the iterator
results in the original string (modulo Unicode replacement codepoint
substitutions if invalid UTF-8 is encountered).</p>
<p>Since sentences are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="string">b&quot;I want this. Not that. Right now.&quot;</span>;
<span class="kw">let</span> <span class="ident">sentences</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">&gt;</span> <span class="op">=</span>
    <span class="ident">bs</span>.<span class="ident">sentence_indices</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sentences</span>, <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="number">0</span>, <span class="number">13</span>, <span class="string">&quot;I want this. &quot;</span>),
    (<span class="number">13</span>, <span class="number">23</span>, <span class="string">&quot;Not that. &quot;</span>),
    (<span class="number">23</span>, <span class="number">33</span>, <span class="string">&quot;Right now.&quot;</span>),
]);</pre></div>
</div><h3 id='method.lines' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='lines.v'>fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.Lines.html" title="struct bstr::Lines">Lines</a></code></h3><div class='docblock'><p>An iterator over all lines in a byte string, without their
terminators.</p>
<p>For this iterator, the only line terminators recognized are <code>\r\n</code> and
<code>\n</code>.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;\
foo

bar\r
baz


quux&quot;</span>;
<span class="kw">let</span> <span class="ident">lines</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">lines</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">lines</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;&quot;</span>), <span class="ident">B</span>(<span class="string">&quot;quux&quot;</span>),
]);</pre></div>
</div><h3 id='method.lines_with_terminator' class='method'><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../bstr/struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../bstr/struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../bstr/struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>;</span></code></div></div><code id='lines_with_terminator.v'>fn <a href='#method.lines_with_terminator' class='fnname'>lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="../bstr/struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a></code></h3><div class='docblock'><p>An iterator over all lines in a byte string, including their
terminators.</p>
<p>For this iterator, the only line terminator recognized is <code>\n</code>. (Since
line terminators are included, this also handles <code>\r\n</code> line endings.)</p>
<p>Line terminators are only included if they are present in the original
byte string. For example, the last line in a byte string may not end
with a line terminator.</p>
<p>Concatenating all elements yielded by this iterator is guaranteed to
yield the original byte string.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;\
foo

bar\r
baz


quux&quot;</span>;
<span class="kw">let</span> <span class="ident">lines</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">lines_with_terminator</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">lines</span>, <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">B</span>(<span class="string">&quot;foo\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;bar\r\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;baz\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;\n&quot;</span>),
    <span class="ident">B</span>(<span class="string">&quot;quux&quot;</span>),
]);</pre></div>
</div><h3 id='method.trim' class='method'><code id='trim.v'>fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with leading and trailing whitespace
removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot; foo\tbar\t\u{2003}\n&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim</span>(), <span class="ident">B</span>(<span class="string">&quot;foo\tbar&quot;</span>));</pre></div>
</div><h3 id='method.trim_start' class='method'><code id='trim_start.v'>fn <a href='#method.trim_start' class='fnname'>trim_start</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with leading whitespace removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot; foo\tbar\t\u{2003}\n&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim_start</span>(), <span class="ident">B</span>(<span class="string">&quot;foo\tbar\t\u{2003}\n&quot;</span>));</pre></div>
</div><h3 id='method.trim_end' class='method'><code id='trim_end.v'>fn <a href='#method.trim_end' class='fnname'>trim_end</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with trailing whitespace removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot; foo\tbar\t\u{2003}\n&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim_end</span>(), <span class="ident">B</span>(<span class="string">&quot; foo\tbar&quot;</span>));</pre></div>
</div><h3 id='method.trim_with' class='method'><code id='trim_with.v'>fn <a href='#method.trim_with' class='fnname'>trim_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with leading and trailing characters
satisfying the given predicate removed.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;123foo5bar789&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim_with</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_numeric</span>()), <span class="ident">B</span>(<span class="string">&quot;foo5bar&quot;</span>));</pre></div>
</div><h3 id='method.trim_start_with' class='method'><code id='trim_start_with.v'>fn <a href='#method.trim_start_with' class='fnname'>trim_start_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with leading characters satisfying the given
predicate removed.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;123foo5bar789&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim_start_with</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_numeric</span>()), <span class="ident">B</span>(<span class="string">&quot;foo5bar789&quot;</span>));</pre></div>
</div><h3 id='method.trim_end_with' class='method'><code id='trim_end_with.v'>fn <a href='#method.trim_end_with' class='fnname'>trim_end_with</a>&lt;F:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></h3><div class='docblock'><p>Return a byte string slice with trailing characters satisfying the
given predicate removed.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">b&quot;123foo5bar&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">trim_end_with</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_numeric</span>()), <span class="ident">B</span>(<span class="string">&quot;123foo5bar&quot;</span>));</pre></div>
</div><h3 id='method.to_lowercase' class='method'><code id='to_lowercase.v'>fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the lowercase equivalent of this
byte string.</p>
<p>In this case, lowercase is defined according to the <code>Lowercase</code> Unicode
property.</p>
<p>If invalid UTF-8 is seen, or if a character has no lowercase variant,
then it is written to the given buffer unchanged.</p>
<p>Note that some characters in this byte string may expand into multiple
characters when changing the case, so the number of bytes written to
the given byte string may not be equivalent to the number of bytes in
this byte string.</p>
<p>If you'd like to reuse an allocation for performance reasons, then use
<a href="#method.to_lowercase_into"><code>to_lowercase_into</code></a> instead.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;HELLO Β&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello β&quot;</span>.<span class="ident">as_bytes</span>(), <span class="ident">s</span>.<span class="ident">to_lowercase</span>().<span class="ident">as_bytes</span>());</pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;农历新年&quot;</span>.<span class="ident">as_bytes</span>(), <span class="ident">s</span>.<span class="ident">to_lowercase</span>().<span class="ident">as_bytes</span>());</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>), <span class="ident">s</span>.<span class="ident">to_lowercase</span>().<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.to_lowercase_into' class='method'><code id='to_lowercase_into.v'>fn <a href='#method.to_lowercase_into' class='fnname'>to_lowercase_into</a>(&amp;self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;)</code></h3><div class='docblock'><p>Writes the lowercase equivalent of this byte string into the given
buffer. The buffer is not cleared before written to.</p>
<p>In this case, lowercase is defined according to the <code>Lowercase</code>
Unicode property.</p>
<p>If invalid UTF-8 is seen, or if a character has no lowercase variant,
then it is written to the given buffer unchanged.</p>
<p>Note that some characters in this byte string may expand into multiple
characters when changing the case, so the number of bytes written to
the given byte string may not be equivalent to the number of bytes in
this byte string.</p>
<p>If you don't need to amortize allocation and instead prefer
convenience, then use <a href="#method.to_lowercase"><code>to_lowercase</code></a> instead.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;HELLO Β&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_lowercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello β&quot;</span>.<span class="ident">as_bytes</span>(), <span class="ident">buf</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_lowercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;农历新年&quot;</span>.<span class="ident">as_bytes</span>(), <span class="ident">buf</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_lowercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>), <span class="ident">buf</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.to_ascii_lowercase' class='method'><code id='to_ascii_lowercase.v'>fn <a href='#method.to_ascii_lowercase' class='fnname'>to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the ASCII lowercase equivalent of
this byte string.</p>
<p>In this case, lowercase is only defined in ASCII letters. Namely, the
letters <code>A-Z</code> are converted to <code>a-z</code>. All other bytes remain unchanged.
In particular, the length of the byte string returned is always
equivalent to the length of this byte string.</p>
<p>If you'd like to reuse an allocation for performance reasons, then use
<a href="#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a> to perform
the conversion in place.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;HELLO Β&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello Β&quot;</span>.<span class="ident">as_bytes</span>(), <span class="ident">s</span>.<span class="ident">to_ascii_lowercase</span>().<span class="ident">as_bytes</span>());</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_ascii_lowercase</span>(), <span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>));</pre></div>
</div><h3 id='method.make_ascii_lowercase' class='method'><code id='make_ascii_lowercase.v'>fn <a href='#method.make_ascii_lowercase' class='fnname'>make_ascii_lowercase</a>(&amp;mut self)</code></h3><div class='docblock'><p>Convert this byte string to its lowercase ASCII equivalent in place.</p>
<p>In this case, lowercase is only defined in ASCII letters. Namely, the
letters <code>A-Z</code> are converted to <code>a-z</code>. All other bytes remain unchanged.</p>
<p>If you don't need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a> instead.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;HELLO Β&quot;</span>);
<span class="ident">s</span>.<span class="ident">make_ascii_lowercase</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;hello Β&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>, <span class="ident">ByteVec</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from_slice</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);
<span class="ident">s</span>.<span class="ident">make_ascii_lowercase</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>));</pre></div>
</div><h3 id='method.to_uppercase' class='method'><code id='to_uppercase.v'>fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the uppercase equivalent of this
byte string.</p>
<p>In this case, uppercase is defined according to the <code>Uppercase</code>
Unicode property.</p>
<p>If invalid UTF-8 is seen, or if a character has no uppercase variant,
then it is written to the given buffer unchanged.</p>
<p>Note that some characters in this byte string may expand into multiple
characters when changing the case, so the number of bytes written to
the given byte string may not be equivalent to the number of bytes in
this byte string.</p>
<p>If you'd like to reuse an allocation for performance reasons, then use
<a href="#method.to_uppercase_into"><code>to_uppercase_into</code></a> instead.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;hello β&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_uppercase</span>(), <span class="ident">B</span>(<span class="string">&quot;HELLO Β&quot;</span>));</pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_uppercase</span>(), <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>));</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_uppercase</span>(), <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</pre></div>
</div><h3 id='method.to_uppercase_into' class='method'><code id='to_uppercase_into.v'>fn <a href='#method.to_uppercase_into' class='fnname'>to_uppercase_into</a>(&amp;self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;)</code></h3><div class='docblock'><p>Writes the uppercase equivalent of this byte string into the given
buffer. The buffer is not cleared before written to.</p>
<p>In this case, uppercase is defined according to the <code>Uppercase</code>
Unicode property.</p>
<p>If invalid UTF-8 is seen, or if a character has no uppercase variant,
then it is written to the given buffer unchanged.</p>
<p>Note that some characters in this byte string may expand into multiple
characters when changing the case, so the number of bytes written to
the given byte string may not be equivalent to the number of bytes in
this byte string.</p>
<p>If you don't need to amortize allocation and instead prefer
convenience, then use <a href="#method.to_uppercase"><code>to_uppercase</code></a> instead.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;hello β&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_uppercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buf</span>, <span class="ident">B</span>(<span class="string">&quot;HELLO Β&quot;</span>));</pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_uppercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buf</span>, <span class="ident">B</span>(<span class="string">&quot;农历新年&quot;</span>));</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="ident">s</span>.<span class="ident">to_uppercase_into</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buf</span>, <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</pre></div>
</div><h3 id='method.to_ascii_uppercase' class='method'><code id='to_ascii_uppercase.v'>fn <a href='#method.to_ascii_uppercase' class='fnname'>to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the ASCII uppercase equivalent of
this byte string.</p>
<p>In this case, uppercase is only defined in ASCII letters. Namely, the
letters <code>a-z</code> are converted to <code>A-Z</code>. All other bytes remain unchanged.
In particular, the length of the byte string returned is always
equivalent to the length of this byte string.</p>
<p>If you'd like to reuse an allocation for performance reasons, then use
<a href="#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a> to perform
the conversion in place.</p>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">&quot;hello β&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_ascii_uppercase</span>(), <span class="ident">B</span>(<span class="string">&quot;HELLO β&quot;</span>));</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">B</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">to_ascii_uppercase</span>(), <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</pre></div>
</div><h3 id='method.make_ascii_uppercase' class='method'><code id='make_ascii_uppercase.v'>fn <a href='#method.make_ascii_uppercase' class='fnname'>make_ascii_uppercase</a>(&amp;mut self)</code></h3><div class='docblock'><p>Convert this byte string to its uppercase ASCII equivalent in place.</p>
<p>In this case, uppercase is only defined in ASCII letters. Namely, the
letters <code>a-z</code> are converted to <code>A-Z</code>. All other bytes remain unchanged.</p>
<p>If you don't need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a> instead.</p>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;hello β&quot;</span>);
<span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">&quot;HELLO β&quot;</span>));</pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>, <span class="ident">ByteVec</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from_slice</span>(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);
<span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</pre></div>
</div><h3 id='method.reverse_bytes' class='method'><code id='reverse_bytes.v'>fn <a href='#method.reverse_bytes' class='fnname'>reverse_bytes</a>(&amp;mut self)</code></h3><div class='docblock'><p>Reverse the bytes in this string, in place.</p>
<p>This is not necessarily a well formed operation! For example, if this
byte string contains valid UTF-8 that isn't ASCII, then reversing the
string will likely result in invalid UTF-8 and otherwise non-sensical
content.</p>
<p>Note that this is equivalent to the generic <code>[u8]::reverse</code> method.
This method is provided to permit callers to explicitly differentiate
between reversing bytes, codepoints and graphemes.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_bytes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;olleh&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.reverse_chars' class='method'><code id='reverse_chars.v'>fn <a href='#method.reverse_chars' class='fnname'>reverse_chars</a>(&amp;mut self)</code></h3><div class='docblock'><p>Reverse the codepoints in this string, in place.</p>
<p>If this byte string is valid UTF-8, then its reversal by codepoint
is also guaranteed to be valid UTF-8.</p>
<p>This operation is equivalent to the following, but without allocating:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;foo☃bar&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">char</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">chars</span>().<span class="ident">collect</span>();
<span class="ident">chars</span>.<span class="ident">reverse</span>();

<span class="kw">let</span> <span class="ident">reversed</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">chars</span>.<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">reversed</span>, <span class="string">&quot;rab☃oof&quot;</span>);</pre></div>
<p>Note that this is not necessarily a well formed operation. For example,
if this byte string contains grapheme clusters with more than one
codepoint, then those grapheme clusters will not necessarily be
preserved. If you'd like to preserve grapheme clusters, then use
<a href="#method.reverse_graphemes"><code>reverse_graphemes</code></a> instead.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;foo☃bar&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_chars</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;rab☃oof&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>This example shows that not all reversals lead to a well formed string.
For example, in this case, combining marks are used to put accents over
some letters, and those accent marks must appear after the codepoints
they modify.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;résumé&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_chars</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">b&quot;\xCC\x81emus\xCC\x81er&quot;</span>));</pre></div>
<p>A word of warning: the above example relies on the fact that
<code>résumé</code> is in decomposed normal form, which means there are separate
codepoints for the accents above <code>e</code>. If it is instead in composed
normal form, then the example works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;résumé&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_chars</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">&quot;émusér&quot;</span>));</pre></div>
<p>The point here is to be cautious and not assume that just because
<code>reverse_chars</code> works in one case, that it therefore works in all
cases.</p>
</div><h3 id='method.reverse_graphemes' class='method'><code id='reverse_graphemes.v'>fn <a href='#method.reverse_graphemes' class='fnname'>reverse_graphemes</a>(&amp;mut self)</code></h3><div class='docblock'><p>Reverse the graphemes in this string, in place.</p>
<p>If this byte string is valid UTF-8, then its reversal by grapheme
is also guaranteed to be valid UTF-8.</p>
<p>This operation is equivalent to the following, but without allocating:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;foo☃bar&quot;</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graphemes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">graphemes</span>().<span class="ident">collect</span>();
<span class="ident">graphemes</span>.<span class="ident">reverse</span>();

<span class="kw">let</span> <span class="ident">reversed</span> <span class="op">=</span> <span class="ident">graphemes</span>.<span class="ident">concat</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">reversed</span>, <span class="string">&quot;rab☃oof&quot;</span>);</pre></div>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;foo☃bar&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_graphemes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;rab☃oof&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
<p>This example shows how this correctly handles grapheme clusters,
unlike <code>reverse_chars</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span>::<span class="ident">from</span>(<span class="string">&quot;résumé&quot;</span>);
<span class="ident">s</span>.<span class="ident">reverse_graphemes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="string">&quot;émusér&quot;</span>.<span class="ident">as_bytes</span>());</pre></div>
</div><h3 id='method.is_ascii' class='method'><code id='is_ascii.v'>fn <a href='#method.is_ascii' class='fnname'>is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Returns true if and only if every byte in this byte string is ASCII.</p>
<p>ASCII is an encoding that defines 128 codepoints. A byte corresponds to
an ASCII codepoint if and only if it is in the inclusive range
<code>[0, 127]</code>.</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">B</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">is_ascii</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">&quot;☃βツ&quot;</span>).<span class="ident">is_ascii</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">b&quot;\xFF&quot;</span>).<span class="ident">is_ascii</span>());</pre></div>
</div><h3 id='method.is_utf8' class='method'><code id='is_utf8.v'>fn <a href='#method.is_utf8' class='fnname'>is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Returns true if and only if the entire byte string is valid UTF-8.</p>
<p>If you need location information about where a byte string's first
invalid UTF-8 byte is, then use the <a href="#method.to_str"><code>to_str</code></a> method.</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">B</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">is_utf8</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">B</span>(<span class="string">&quot;☃βツ&quot;</span>).<span class="ident">is_utf8</span>());
<span class="comment">// invalid bytes</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">b&quot;abc\xFF&quot;</span>).<span class="ident">is_utf8</span>());
<span class="comment">// surrogate encoding</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">b&quot;\xED\xA0\x80&quot;</span>).<span class="ident">is_utf8</span>());
<span class="comment">// incomplete sequence</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">b&quot;\xF0\x9D\x9Ca&quot;</span>).<span class="ident">is_utf8</span>());
<span class="comment">// overlong sequence</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">B</span>(<span class="string">b&quot;\xF0\x82\x82\xAC&quot;</span>).<span class="ident">is_utf8</span>());</pre></div>
</div><h3 id='method.last_byte' class='method'><code id='last_byte.v'>fn <a href='#method.last_byte' class='fnname'>last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;</code></h3><div class='docblock'><p>Returns the last byte in this byte string, if it's non-empty. If this
byte string is empty, this returns <code>None</code>.</p>
<p>Note that this is like the generic <code>[u8]::last</code>, except this returns
the byte by value instead of a reference to the byte.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::<span class="ident">ByteSlice</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;z&#39;</span>), <span class="string">b&quot;baz&quot;</span>.<span class="ident">last_byte</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;&quot;</span>.<span class="ident">last_byte</span>());</pre></div>
</div><h3 id='method.find_non_ascii_byte' class='method'><code id='find_non_ascii_byte.v'>fn <a href='#method.find_non_ascii_byte' class='fnname'>find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code></h3><div class='docblock'><p>Returns the index of the first non-ASCII byte in this byte string (if
any such indices exist). Specifically, it returns the index of the
first byte with a value greater than or equal to <code>0x80</code>.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">ByteSlice</span>, <span class="ident">B</span>};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="string">b&quot;abc\xff&quot;</span>.<span class="ident">find_non_ascii_byte</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;abcde&quot;</span>.<span class="ident">find_non_ascii_byte</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">B</span>(<span class="string">&quot;😀&quot;</span>).<span class="ident">find_non_ascii_byte</span>());</pre></div>
</div><h3 id='method.copy_within_str' class='method'><code id='copy_within_str.v'>fn <a href='#method.copy_within_str' class='fnname'>copy_within_str</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></code></h3><div class='docblock'><p>Copies elements from one part of the slice to another part of itself,
where the parts may be overlapping.</p>
<p><code>src</code> is the range within this byte string to copy from, while <code>dest</code>
is the starting index of the range within this byte string to copy to.
The length indicated by <code>src</code> must be less than or equal to the number
of bytes from <code>dest</code> to the end of the byte string.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if either range is out of bounds, or if <code>src</code> is too big to fit
into <code>dest</code>, or if the end of <code>src</code> is before the start.</p>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<p>Copying four bytes within a byte string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bstr</span>::{<span class="ident">B</span>, <span class="ident">ByteSlice</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="kw-2">*</span><span class="string">b&quot;Hello, World!&quot;</span>;
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>;
<span class="ident">s</span>.<span class="ident">copy_within_str</span>(<span class="number">1</span>..<span class="number">5</span>, <span class="number">8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">B</span>(<span class="string">&quot;Hello, Wello!&quot;</span>));</pre></div>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='foreign-impls' class='small-section-header'>Implementations on Foreign Types<a href='#foreign-impls' class='anchor'></a></h2><h3 id='impl-ByteSlice-for-%5Bu8%5D' class='impl'><code class='in-band'>impl <a class="trait" href="../bstr/trait.ByteSlice.html" title="trait bstr::ByteSlice">ByteSlice</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a href='#impl-ByteSlice-for-%5Bu8%5D' class='anchor'></a><a class='srclink' href='../src/bstr/ext_slice.rs.html#80-87' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_bytes' class="method hidden"><code id='as_bytes.v'>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a class='srclink' href='../src/bstr/ext_slice.rs.html#81-83' title='goto source code'>[src]</a></h4><h4 id='method.as_bytes_mut' class="method hidden"><code id='as_bytes_mut.v'>fn <a href='#method.as_bytes_mut' class='fnname'>as_bytes_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a class='srclink' href='../src/bstr/ext_slice.rs.html#84-86' title='goto source code'>[src]</a></h4></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><span class='loading-content'>Loading content...</span><script type="text/javascript">window.inlined_types=new Set([]);</script><script type="text/javascript" async
                         src="../implementors/bstr/trait.ByteSlice.js">
                 </script></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "bstr";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>